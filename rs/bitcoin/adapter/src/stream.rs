use bitcoin::{
    consensus::serialize,
    network::message::RawNetworkMessage,
    {consensus::encode, network::message::NetworkMessage},
};
use ic_logger::{debug, error, ReplicaLogger};
use std::{io, net::SocketAddr, pin::Pin, time::Duration};
use thiserror::Error;
use tokio::{
    io::{AsyncRead, AsyncWrite, AsyncWriteExt},
    net::TcpStream,
    sync::mpsc::{Sender, UnboundedReceiver},
    time::timeout,
};
use tokio_socks::{tcp::Socks5Stream, Error as SocksError};

/// This provides a default amount of time to wait before a timeout occurs while
/// attempting to connect to a BTC node.
const CONNECTION_TIMEOUT_SECS: u64 = 5;

/// This constant represents the size of the buffer needed when reading messages
/// from the Bitcoin node.
const STREAM_BUFFER_SIZE: usize = 64 * 1024;

/// This enum is used to represent the possible errors that could occur while a stream
/// is connected.
#[derive(Debug, Error)]
pub enum StreamError {
    /// This variant is used to indicate that there was an error while connecting
    /// that involved the SOCKS proxy.
    #[error("{0}")]
    Socks(SocksError),
    /// This variant is used to indicate an error occurred while communicating
    /// using the TcpStream.
    #[error("{0}")]
    Io(io::Error),
    /// This variant is used to indicate an error while encoding or decoding the network
    /// message.
    #[error("{0}")]
    Encode(encode::Error),
    /// This variant is used to indicate that the stream has become disconnected
    /// from the parent task.
    #[error("This stream has become disconnected from the main task.")]
    UnableToReceiveMessages,
    /// This .
    #[error("Connecting to the stream timed out.")]
    Timeout,
}

/// This type is a wrapper for results that contain StreamError.
pub type StreamResult<T> = Result<T, StreamError>;

/// This struct represents the configuration options for a Stream struct.
pub struct StreamConfig {
    /// This field represents the target address that the stream will connect to.
    pub address: SocketAddr,
    /// This field is used to provide an instance of the logger.
    pub logger: ReplicaLogger,
    /// This field is used to provide the magic value to the raw network message.
    /// The magic number is used to identity the type of Bitcoin network being accessed.
    pub magic: u32,
    /// This field is used to receive network messages to send out to the connected
    /// BTC node.
    pub network_message_receiver: UnboundedReceiver<NetworkMessage>,
    /// This field represents the address that the stream may use to proxy
    /// requests to the address field.
    pub socks_proxy: Option<SocketAddr>,
    /// This field is used to send events from the stream back to the network and connection structs.
    pub stream_event_sender: Sender<StreamEvent>,
}

/// This struct is used to represent an event that has occurred within the Stream
/// struct.
pub struct StreamEvent {
    /// This field is used to help identify which stream created the event.
    pub address: SocketAddr,
    /// This field is used to determine what happened with the stream.
    pub kind: StreamEventKind,
}

/// This enum is used to represent events generated by the Stream struct.
/// This is how we handle the stream interactions.
pub enum StreamEventKind {
    /// This variant is used to indicate that the stream has been established.
    Connected,
    /// This variant is used to indicate that the stream has been disconnected.
    Disconnected,
    /// This variant is used to indicate that the connection failed due to an
    /// I/O error or timeout.
    FailedToConnect,
    /// This variant is used to indicate a new network message has been received.
    Message(NetworkMessage),
}

/// This struct is used to provide an interface with the raw socket that will
/// be connecting to the BTC node.
pub struct Stream {
    /// This field is used to identity the node that the stream is connected to.
    address: SocketAddr,
    /// This field is used as the buffer for reading messages.
    data: Vec<u8>,
    /// This field contains the actual stream handling the network connection.
    inner: TcpStream,
    /// This field is used to provide the magic value to the raw network message.
    /// The magic number is used to identity the type of Bitcoin network being accessed.
    magic: u32,
    /// This field contains the receiver used to intake messages that are to be
    /// sent to the connected node.
    network_message_receiver: UnboundedReceiver<NetworkMessage>,
    /// This field is used to send events from the stream back to the network and connection structs.
    stream_event_sender: Sender<StreamEvent>,
    /// This field is used as a buffer to contain unparsed message parts.
    unparsed: Vec<u8>,
}

impl Stream {
    /// Creates new SOCKS client. In case of missing proxy address we fall back to the direct TCP
    /// stream.
    pub async fn connect(config: StreamConfig) -> StreamResult<Stream> {
        let StreamConfig {
            address,
            socks_proxy,
            stream_event_sender,
            magic,
            network_message_receiver,
            ..
        } = config;

        let timeout_duration = Duration::from_secs(CONNECTION_TIMEOUT_SECS);
        let data = vec![0u8; STREAM_BUFFER_SIZE];
        let unparsed = vec![];
        let inner = match socks_proxy {
            Some(socks_proxy) => {
                let proxy_result = timeout(timeout_duration, TcpStream::connect(socks_proxy))
                    .await
                    .map_err(|_| StreamError::Timeout)?;
                let proxy = proxy_result.map_err(StreamError::Io)?;
                proxy.set_nodelay(true).map_err(StreamError::Io)?;

                let socks_timeout = timeout(
                    timeout_duration,
                    Socks5Stream::connect_with_socket(proxy, address),
                )
                .await
                .map_err(|_| StreamError::Timeout)?;

                let socks_stream = socks_timeout.map_err(StreamError::Socks)?;
                socks_stream.into_inner()
            }
            None => {
                let connect_result = timeout(timeout_duration, TcpStream::connect(&address))
                    .await
                    .map_err(|_| StreamError::Timeout)?;
                connect_result.map_err(StreamError::Io)?
            }
        };
        Ok(Self {
            address,
            data,
            inner,
            magic,
            network_message_receiver,
            stream_event_sender,
            unparsed,
        })
    }

    /// This function reads a message from the inner TcpStream.
    pub fn read_message(&mut self) -> StreamResult<RawNetworkMessage> {
        loop {
            // The stream may only a message partial from the Bitcoin node.
            // Due to this, the stream must attempt to deserialize partial messages.
            match encode::deserialize_partial::<RawNetworkMessage>(&self.unparsed) {
                // If there was an I/O error found in the unparsed message and it was an unexpected
                // end-of-file, then the stream should try to read again. If the read fails, the stream
                // exits the read message with the error. The stream later looks at this error, if the
                // kind is WouldBlock, the stream continues; otherwise, the stream will disconnect.
                // If the read successfully received bytes, then the bytes are added to the
                // unparsed buffer to attempt another deserialize call. If no bytes found,
                // return the unexpected end-of-file error.
                Err(encode::Error::Io(ref err)) if err.kind() == io::ErrorKind::UnexpectedEof => {
                    let count = self
                        .inner
                        .try_read(&mut self.data)
                        .map_err(StreamError::Io)?;

                    if count == 0 {
                        return Err(StreamError::Io(io::Error::from(
                            io::ErrorKind::UnexpectedEof,
                        )));
                    }

                    if let Some(slice) = self.data.get(0..count) {
                        self.unparsed.extend(slice.iter());
                    }
                }
                // If an error occurred, that is not an unexpected end-of-file, unwrap the error
                // and then re-wrap it into a StreamError.
                Err(err) => {
                    return Err(match err {
                        encode::Error::Io(err) => StreamError::Io(err),
                        err => StreamError::Encode(err),
                    })
                }
                // If the message can be parsed, the unparsed buffer is drained and the message
                // is returned.
                Ok((message, index)) => {
                    self.unparsed.drain(..index);
                    return Ok(message);
                }
            }
        }
    }

    /// This function is used to write a network message to the connected Bitcoin
    /// node.
    async fn write_message(&mut self, network_message: NetworkMessage) -> StreamResult<()> {
        let raw_network_message = RawNetworkMessage {
            magic: self.magic,
            payload: network_message,
        };
        let bytes = serialize(&raw_network_message);
        self.write(bytes.as_slice())
            .await
            .map_err(StreamError::Io)?;
        self.flush().await.map_err(StreamError::Io)
    }

    /// This function is used to handle a single iteration of the stream.
    /// First, the stream writes the latest message on the network message receiver to the BTC node.
    /// Second, the stream attempt to read a message from the BTC node. If no message is found,
    /// the stream tick completes. If a message is found, the stream sends a StreamEvent on the
    /// stream event sender so the Network struct may react.
    pub async fn tick(&mut self) -> StreamResult<()> {
        if let Ok(network_message) = self.network_message_receiver.try_recv() {
            self.write_message(network_message).await?;
        }
        match self.read_message() {
            Ok(raw_message) => {
                let result = self
                    .stream_event_sender
                    .send(StreamEvent {
                        address: self.address,
                        kind: StreamEventKind::Message(raw_message.payload),
                    })
                    .await;
                if result.is_err() {
                    return Err(StreamError::UnableToReceiveMessages);
                }
            }
            Err(err) => match err {
                StreamError::Io(io_err) => match io_err.kind() {
                    io::ErrorKind::WouldBlock => {}
                    _ => return Err(StreamError::Io(io_err)),
                },
                _ => return Err(err),
            },
        };
        Ok(())
    }
}

/// This function is used to kick off a new stream that will be connected to a
/// the Network struct and related connection struct via a set of channels.
pub async fn handle_stream(config: StreamConfig) {
    let address = config.address;
    let logger = config.logger.clone();
    // Clone the sender here to handle errors that the Stream may return.
    let stream_event_sender = config.stream_event_sender.clone();
    debug!(logger, "Connecting to {}", address);
    let stream_result = Stream::connect(config).await;
    let mut stream = match stream_result {
        Ok(stream) => {
            stream_event_sender
                .send(StreamEvent {
                    address,
                    kind: StreamEventKind::Connected,
                })
                .await
                .ok();
            stream
        }
        Err(err) => {
            let kind = match err {
                StreamError::Io(err) => {
                    debug!(logger, "{}", err);
                    StreamEventKind::FailedToConnect
                }
                StreamError::Timeout => {
                    debug!(logger, "Timed out connecting to {}", address);
                    StreamEventKind::FailedToConnect
                }
                _ => {
                    error!(logger, "{}", err);
                    StreamEventKind::Disconnected
                }
            };
            stream_event_sender
                .send(StreamEvent { address, kind })
                .await
                .ok();
            return;
        }
    };

    loop {
        if stream.tick().await.is_err() {
            stream_event_sender
                .send(StreamEvent {
                    address,
                    kind: StreamEventKind::Disconnected,
                })
                .await
                .ok();
            return;
        };

        tokio::time::sleep(Duration::from_millis(250)).await;
    }
}

impl AsyncRead for Stream {
    fn poll_read(
        mut self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
        buf: &mut tokio::io::ReadBuf<'_>,
    ) -> std::task::Poll<std::io::Result<()>> {
        AsyncRead::poll_read(Pin::new(&mut self.inner), cx, buf)
    }
}

impl AsyncWrite for Stream {
    fn poll_write(
        mut self: Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
        buf: &[u8],
    ) -> std::task::Poll<Result<usize, std::io::Error>> {
        AsyncWrite::poll_write(Pin::new(&mut self.inner), cx, buf)
    }

    fn poll_flush(
        mut self: Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Result<(), std::io::Error>> {
        AsyncWrite::poll_flush(Pin::new(&mut self.inner), cx)
    }

    fn poll_shutdown(
        mut self: Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Result<(), std::io::Error>> {
        AsyncWrite::poll_shutdown(Pin::new(&mut self.inner), cx)
    }
}
