/* tag::catalog[]
Title:: Payload Builder Size Tests

Goal:: Test the consensus payload builder and the accompaning payload validator.

Runbook::
. Set up two subnets with one fast node each
. Install a universal canister in both, one is called target canister the other assist canister.
. The assist canister will be used to send the xnet data to the target canister.
. Send ingress message to target canister, that is slightly below maximum size. Expect it to succeed.
. Send xnet message to target canister, that is slightly below maximum size. Expect it to succeed.
. Send a bunch of large xnet and ingress messages to the same canister. Expect it to handle all of them eventually.

Success:: The payload builder respects the boundaries set by the registry, while the payload validator
accepts all payloads generated by the payload builder.

Coverage::
. The maximum size of an individual ingress message is respected.
. The maximum size of an individual xnet message is respected.
. The system handles well under the load of large ingress messages and xnet messages at the same time.

end::catalog[] */

use crate::util::{
    assert_all_ready, assert_create_agent, get_random_non_root_node_endpoint,
    get_random_root_node_endpoint, UniversalCanister,
};
use futures::{join, stream::FuturesUnordered, StreamExt};
use ic_agent::{Agent, AgentError};
use ic_fondue::{
    ic_instance::{LegacyInternetComputer as InternetComputer, Subnet},
    ic_manager::IcHandle,
};
use ic_registry_subnet_type::SubnetType;
use ic_universal_canister::{call_args, wasm};
use slog::{info, Logger};
use std::sync::Arc;

const INGRESS_MAX_SIZE: usize = 4 * 1024 * 1024;
const XNET_MAX_SIZE: usize = 2 * 1024 * 1024;

// NOTE: Unfortunately, the maximum sizes can not be used in the test.
// In both cases, we have to account for the extra command bytes of the unican,
// that preceed the message. In the case of the ingress messages, we also have
// to account for the ingress message header.
const INGRESS_MSG_SIZE: usize = 4 * 1024 * 1024 - 360;
const XNET_MSG_SIZE: usize = 2 * 1024 * 1024 - 20;

/// Configuration that is used for the maximum payload size tests.
/// In this test, the payload size is set to 2MiB and the ingress size to 4MiB.
/// This allows us to test, that in a misconfigured setting, the specified
/// max_block_payload_size still fits through.
/// It also allows us to test the limit in the XNet setting properly.
pub fn max_payload_size_config() -> InternetComputer {
    InternetComputer::new()
        .add_subnet(
            Subnet::new(SubnetType::System)
                .add_nodes(1)
                .with_max_block_payload_size(XNET_MAX_SIZE as u64)
                .with_max_ingress_message_size(INGRESS_MAX_SIZE as u64),
        )
        .add_subnet(
            Subnet::new(SubnetType::Application)
                .add_nodes(1)
                .with_max_block_payload_size(XNET_MAX_SIZE as u64)
                .with_max_ingress_message_size(INGRESS_MAX_SIZE as u64),
        )
}

const DW_NUM_MSGS: usize = 32;
const DW_MAX_SIZE: usize = 2 * 1024 * 1024;
const DW_MSG_SIZE: usize = 2 * 1000 * 1000;

/// The configuration that is used for the dual workload test.
/// In this configuration, all sizes are set to 2MiB.
pub fn dual_workload_config() -> InternetComputer {
    InternetComputer::new()
        .add_subnet(
            Subnet::new(SubnetType::System)
                .add_nodes(1)
                .with_max_block_payload_size(DW_MAX_SIZE as u64)
                .with_max_ingress_message_size(DW_MAX_SIZE as u64),
        )
        .add_subnet(Subnet::new(SubnetType::Application).add_nodes(1))
}

#[derive(Debug)]
enum PayloadType {
    Ingress(usize),
    XNet(usize),
}

/// Tests, that an ingress message that is close to the maximum size is accepted
/// by the block maker, whereas a message this is exactly the maximum size is
/// not accepted.
pub fn max_ingress_payload_size_test(handle: IcHandle, ctx: &ic_fondue::pot::Context) {
    let rt = tokio::runtime::Runtime::new().expect("Could not create tokio runtime.");

    rt.block_on(async move {
        let (assist_agent, target_agent) = setup_agents(&handle, ctx).await;
        let (_, target_unican) = setup_unicans(&assist_agent, &target_agent).await;

        // Send a message that is supposed to fit.
        make_ingress_call(&target_unican, INGRESS_MSG_SIZE)
            .await
            .unwrap();
    })
}

/// Tests, that a xnet message that is close to the maximum size is accepted
/// by the block maker, whereas a message this is exactly the maximum size is
/// not accepted.
pub fn max_xnet_payload_size_test(handle: IcHandle, ctx: &ic_fondue::pot::Context) {
    let rt = tokio::runtime::Runtime::new().expect("Could not create tokio runtime.");

    rt.block_on(async move {
        let (assist_agent, target_agent) = setup_agents(&handle, ctx).await;
        let (assist_unican, target_unican) = setup_unicans(&assist_agent, &target_agent).await;

        // Send a message that is supposed to fit.
        make_xnet_call(&target_unican, &assist_unican, XNET_MSG_SIZE)
            .await
            .unwrap();
    });
}

/// Tests, that the internet computer behaves well, when there is a high load of
/// ingress messages and xnet messages on the same subnet.
pub fn dual_workload_test(handle: IcHandle, ctx: &ic_fondue::pot::Context) {
    let logger = &ctx.logger;
    let rt = tokio::runtime::Runtime::new().expect("Could not create tokio runtime.");

    rt.block_on(async move {
        let (assist_agent, target_agent) = setup_agents(&handle, ctx).await;
        let (assist_unican, target_unican) = setup_unicans(&assist_agent, &target_agent).await;

        let calls = (0..DW_NUM_MSGS)
            .flat_map(|x| vec![PayloadType::XNet(x), PayloadType::Ingress(x)])
            .map(|report| {
                (
                    target_unican.clone(),
                    assist_unican.clone(),
                    report,
                    logger.clone(),
                )
            })
            .map(|(target_unican, assist_unican, report, logger)| {
                make_dual_call(target_unican, assist_unican, report, DW_MSG_SIZE, logger)
            })
            .collect::<FuturesUnordered<_>>()
            .collect::<Vec<_>>();

        info!(logger, "Calls are setup, will be submitted now");
        let reports = calls.await;
        info!(logger, "Report: {:?}", reports)
    });
}

async fn setup_agents(handle: &IcHandle, ctx: &ic_fondue::pot::Context) -> (Agent, Agent) {
    let mut rng = ctx.rng.clone();

    // Choose one node from each subnet
    let assist_node = get_random_non_root_node_endpoint(handle, &mut rng);
    let target_node = get_random_root_node_endpoint(handle, &mut rng);

    // Check that they are ready for operation
    assert_all_ready(&[target_node, assist_node], ctx).await;

    // Create the agents
    join!(
        assert_create_agent(assist_node.url.as_str()),
        assert_create_agent(target_node.url.as_str())
    )
}

async fn setup_unicans<'a>(
    assist_agent: &'a Agent,
    target_agent: &'a Agent,
) -> (Arc<UniversalCanister<'a>>, Arc<UniversalCanister<'a>>) {
    // Install a `UniversalCanister` on each
    let (assist_unican, target_unican) = join!(
        UniversalCanister::new(assist_agent),
        UniversalCanister::new(target_agent)
    );

    // NOTE: Since we will be making calls to these canisters in parallel, we have
    // to make it `Send`.
    let (assist_unican, target_unican) = (Arc::new(assist_unican), Arc::new(target_unican));

    // Grow the stable memory so it can actually store the amount of data
    join!(
        stable_grow(&assist_unican, 100),
        stable_grow(&target_unican, 100)
    );

    (assist_unican, target_unican)
}

/// Used in the dual workload test. Depending on the `PayloadType`, the function
/// will either make an ingress call to `target_unican` or a Xnet call from
/// `assist_unican` to `target_unican`.
async fn make_dual_call<'a>(
    target_unican: Arc<UniversalCanister<'a>>,
    assist_unican: Arc<UniversalCanister<'a>>,
    call_ctx: PayloadType,
    size: usize,
    logger: Logger,
) -> PayloadType {
    match call_ctx {
        PayloadType::XNet(i) => {
            make_xnet_call(&target_unican, &assist_unican, size)
                .await
                .unwrap();
            info!(logger, "XNet call {:?} finished", i);
        }
        PayloadType::Ingress(i) => {
            make_ingress_call(&target_unican, size).await.unwrap();
            info!(logger, "Ingress call {:?} finished", i);
        }
    }

    call_ctx
}

/// Makes an ingress call to the specified canister with a message of the
/// specified size.
async fn make_ingress_call(
    dst: &UniversalCanister<'_>,
    size: usize,
) -> Result<Vec<u8>, AgentError> {
    // NOTE: We use reply here before stable write, since we don't actually
    // care about the write, we just want to send a large message.
    dst.update(wasm().reply().stable_write(0, &vec![0; size]))
        .await
}

/// Makes a XNet call from the `src` canister to the `dst` canister with a
/// message of the specified size
async fn make_xnet_call(
    dst: &UniversalCanister<'_>,
    src: &UniversalCanister<'_>,
    size: usize,
) -> Result<Vec<u8>, AgentError> {
    src.update(
        wasm().inter_update(
            dst.canister_id(),
            call_args()
                // NOTE: We use reply here before stable write, since we don't actually
                // care about the write, we just want to send a large message.
                .other_side(wasm().reply().stable_write(0, &vec![0; size]))
                .on_reply(wasm().reply()),
        ),
    )
    .await
}

/// Grow the canisters stable memory by the given number of pages
async fn stable_grow(unican: &UniversalCanister<'_>, num_pages: u32) {
    unican
        .update(wasm().stable_grow(num_pages).reply())
        .await
        .unwrap();
}
