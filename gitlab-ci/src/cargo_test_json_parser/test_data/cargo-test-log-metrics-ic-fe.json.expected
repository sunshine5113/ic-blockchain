{
  "__index": "cargo-test-results-job-name-2020",
  "failed": 1,
  "ignored": 0,
  "passed": 49,
  "results": {
    "handler::get_nns_subnet_id_tests::works_with_multi_node_subnets": {
      "event": "ok"
    },
    "handler::get_nns_subnet_id_tests::works_with_single_node_subnets": {
      "event": "ok"
    },
    "handler::ic_event::read_state_request_tests::read_state_request_one_path": {
      "event": "ok"
    },
    "handler::ic_event::read_state_request_tests::read_state_request_two_paths": {
      "event": "ok"
    },
    "handler::ic_event::read_state_response_tests::read_state_response_done": {
      "event": "ok"
    },
    "handler::ic_event::read_state_response_tests::read_state_response_rejected": {
      "event": "ok"
    },
    "handler::ic_http::tests::validate_request_forbidden_http_verbs": {
      "event": "ok"
    },
    "handler::ic_http::tests::validate_request_get_other_paths": {
      "event": "ok"
    },
    "handler::ic_http::tests::validate_request_get_status": {
      "event": "ok"
    },
    "handler::ic_http::tests::validate_request_options": {
      "event": "ok"
    },
    "handler::ic_http::tests::validate_request_post_content_type_incorrect": {
      "event": "ok"
    },
    "handler::ic_http::tests::validate_request_post_content_type_missing": {
      "event": "ok"
    },
    "handler::ic_http::tests::validate_request_post_other_paths": {
      "event": "ok"
    },
    "handler::ic_http::tests::validate_request_post_valid_request": {
      "event": "ok"
    },
    "handler::read::pick_tests::pick_subnet_query_from_canister_id": {
      "event": "ok"
    },
    "handler::read::pick_tests::pick_subnet_query_missing_canister_id": {
      "event": "ok"
    },
    "handler::read::pick_tests::pick_subnet_read_state_no_request_status": {
      "event": "ok"
    },
    "handler::read::pick_tests::pick_subnet_read_state_request_status_cache_hit": {
      "event": "ok"
    },
    "handler::read::pick_tests::pick_subnet_read_state_request_status_cache_miss": {
      "event": "ok"
    },
    "handler::read::pick_tests::pick_subnet_read_state_request_status_multiple_different": {
      "event": "ok"
    },
    "handler::read::pick_tests::pick_subnet_read_state_request_status_multiple_same_cache_hit": {
      "event": "ok"
    },
    "handler::read::pick_tests::pick_subnet_request_status_cache_hit": {
      "event": "ok"
    },
    "handler::read::pick_tests::pick_subnet_request_status_cache_miss": {
      "event": "ok"
    },
    "handler::read::validate_tests::validate_corrupt_cbor": {
      "event": "ok"
    },
    "handler::read::validate_tests::validate_srr_query": {
      "event": "ok"
    },
    "handler::read::validate_tests::validate_srr_request_status": {
      "event": "ok"
    },
    "handler::submit::pick_tests::pick_subnet_ic_00_create_canister": {
      "event": "ok"
    },
    "handler::submit::pick_tests::pick_subnet_ic_00_other_method": {
      "event": "ok"
    },
    "handler::submit::pick_tests::pick_subnet_non_mgmt": {
      "event": "ok"
    },
    "handler::submit::validate_tests::validate_corrupt_cbor": {
      "event": "ok"
    },
    "handler::submit::validate_tests::validate_signed_ingress": {
      "event": "ok"
    },
    "reverse_proxy::tests::cpr_for_header_ipv6": {
      "event": "ok"
    },
    "reverse_proxy::tests::cpr_minimal_changes": {
      "event": "ok"
    },
    "reverse_proxy::tests::cpr_strip_connection_headers": {
      "event": "failed",
      "stdout": "thread 'reverse_proxy::tests::cpr_strip_connection_headers' panicked at 'assertion failed: `(left == right)`\n\n\u001b[1mDiff\u001b[0m \u001b[31m< left\u001b[0m / \u001b[32mright >\u001b[0m :\n\u001b[31m<\u001b[0m\u001b[1;48;5;52;31m0\u001b[0m\n\u001b[32m>\u001b[0m\u001b[1;48;5;22;32m2\u001b[0m\n\n', ic_fe/src/reverse_proxy.rs:554:9\nstack backtrace:\n   0: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\n   1: core::fmt::write\n   2: std::io::Write::write_fmt\n   3: std::io::impls::<impl std::io::Write for alloc::boxed::Box<W>>::write_fmt\n   4: std::panicking::default_hook::{{closure}}\n   5: std::panicking::default_hook\n   6: std::panicking::rust_panic_with_hook\n   7: rust_begin_unwind\n   8: std::panicking::begin_panic_fmt\n   9: ic_fe::reverse_proxy::tests::cpr_strip_connection_headers\n             at ic_fe/src/reverse_proxy.rs:554\n  10: ic_fe::reverse_proxy::tests::cpr_strip_connection_headers::{{closure}}\n             at ic_fe/src/reverse_proxy.rs:553\n  11: core::ops::function::FnOnce::call_once\n             at /build/rustc-1.45.2-src/src/libcore/ops/function.rs:232\n  12: test::run_test_in_process\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\n"
    },
    "reverse_proxy::tests::cpr_strip_hop_headers_keep_upgrade": {
      "event": "ok"
    },
    "reverse_proxy::tests::cpr_strip_hop_headers_non_upgrade": {
      "event": "ok"
    },
    "reverse_proxy::tests::cpr_via_http_10": {
      "event": "ok"
    },
    "reverse_proxy::tests::cpr_x_forwarded_for_appends": {
      "event": "ok"
    },
    "reverse_proxy::tests::double_1": {
      "event": "ok"
    },
    "reverse_proxy::tests::double_2": {
      "event": "ok"
    },
    "reverse_proxy::tests::double_3": {
      "event": "ok"
    },
    "reverse_proxy::tests::double_4": {
      "event": "ok"
    },
    "reverse_proxy::tests::empty_1": {
      "event": "ok"
    },
    "reverse_proxy::tests::empty_2": {
      "event": "ok"
    },
    "reverse_proxy::tests::empty_3": {
      "event": "ok"
    },
    "reverse_proxy::tests::order_1": {
      "event": "ok"
    },
    "reverse_proxy::tests::single_1": {
      "event": "ok"
    },
    "reverse_proxy::tests::single_2": {
      "event": "ok"
    },
    "reverse_proxy::tests::single_3": {
      "event": "ok"
    },
    "reverse_proxy::tests::single_4": {
      "event": "ok"
    }
  },
  "test_count": 50
}
