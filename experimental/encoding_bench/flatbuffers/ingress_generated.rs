#![allow(unused_code)]
#![allow(unused_imports)]
// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod encoding_bench {

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::EndianScalar;
    #[allow(unused_imports, dead_code)]
    pub mod ingress {

        use std::cmp::Ordering;
        use std::mem;

        extern crate flatbuffers;
        use self::flatbuffers::EndianScalar;

        pub enum IngressOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct Ingress<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for Ingress<'a> {
            type Inner = Ingress<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf: buf, loc: loc },
                }
            }
        }

        impl<'a> Ingress<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                Ingress { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args IngressArgs<'args>,
            ) -> flatbuffers::WIPOffset<Ingress<'bldr>> {
                let mut builder = IngressBuilder::new(_fbb);
                builder.add_message_time_ns(args.message_time_ns);
                builder.add_message_id(args.message_id);
                builder.add_receiver(args.receiver);
                builder.add_source(args.source);
                if let Some(x) = args.method_payload {
                    builder.add_method_payload(x);
                }
                if let Some(x) = args.method_name {
                    builder.add_method_name(x);
                }
                builder.finish()
            }

            pub const VT_SOURCE: flatbuffers::VOffsetT = 4;
            pub const VT_RECEIVER: flatbuffers::VOffsetT = 6;
            pub const VT_METHOD_NAME: flatbuffers::VOffsetT = 8;
            pub const VT_METHOD_PAYLOAD: flatbuffers::VOffsetT = 10;
            pub const VT_MESSAGE_ID: flatbuffers::VOffsetT = 12;
            pub const VT_MESSAGE_TIME_NS: flatbuffers::VOffsetT = 14;

            #[inline]
            pub fn source(&self) -> u64 {
                self._tab.get::<u64>(Ingress::VT_SOURCE, Some(0)).unwrap()
            }
            #[inline]
            pub fn receiver(&self) -> u64 {
                self._tab.get::<u64>(Ingress::VT_RECEIVER, Some(0)).unwrap()
            }
            #[inline]
            pub fn method_name(&self) -> Option<&'a str> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Ingress::VT_METHOD_NAME, None)
            }
            #[inline]
            pub fn method_payload(&self) -> Option<&'a [u8]> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Ingress::VT_METHOD_PAYLOAD,
                        None,
                    )
                    .map(|v| v.safe_slice())
            }
            #[inline]
            pub fn message_id(&self) -> u64 {
                self._tab
                    .get::<u64>(Ingress::VT_MESSAGE_ID, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn message_time_ns(&self) -> u64 {
                self._tab
                    .get::<u64>(Ingress::VT_MESSAGE_TIME_NS, Some(0))
                    .unwrap()
            }
        }

        pub struct IngressArgs<'a> {
            pub source: u64,
            pub receiver: u64,
            pub method_name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub method_payload: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
            pub message_id: u64,
            pub message_time_ns: u64,
        }
        impl<'a> Default for IngressArgs<'a> {
            #[inline]
            fn default() -> Self {
                IngressArgs {
                    source: 0,
                    receiver: 0,
                    method_name: None,
                    method_payload: None,
                    message_id: 0,
                    message_time_ns: 0,
                }
            }
        }
        pub struct IngressBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> IngressBuilder<'a, 'b> {
            #[inline]
            pub fn add_source(&mut self, source: u64) {
                self.fbb_.push_slot::<u64>(Ingress::VT_SOURCE, source, 0);
            }
            #[inline]
            pub fn add_receiver(&mut self, receiver: u64) {
                self.fbb_
                    .push_slot::<u64>(Ingress::VT_RECEIVER, receiver, 0);
            }
            #[inline]
            pub fn add_method_name(&mut self, method_name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    Ingress::VT_METHOD_NAME,
                    method_name,
                );
            }
            #[inline]
            pub fn add_method_payload(
                &mut self,
                method_payload: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    Ingress::VT_METHOD_PAYLOAD,
                    method_payload,
                );
            }
            #[inline]
            pub fn add_message_id(&mut self, message_id: u64) {
                self.fbb_
                    .push_slot::<u64>(Ingress::VT_MESSAGE_ID, message_id, 0);
            }
            #[inline]
            pub fn add_message_time_ns(&mut self, message_time_ns: u64) {
                self.fbb_
                    .push_slot::<u64>(Ingress::VT_MESSAGE_TIME_NS, message_time_ns, 0);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IngressBuilder<'a, 'b> {
                let start = _fbb.start_table();
                IngressBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<Ingress<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        #[inline]
        pub fn get_root_as_ingress<'a>(buf: &'a [u8]) -> Ingress<'a> {
            flatbuffers::get_root::<Ingress<'a>>(buf)
        }

        #[inline]
        pub fn get_size_prefixed_root_as_ingress<'a>(buf: &'a [u8]) -> Ingress<'a> {
            flatbuffers::get_size_prefixed_root::<Ingress<'a>>(buf)
        }

        #[inline]
        pub fn finish_ingress_buffer<'a, 'b>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            root: flatbuffers::WIPOffset<Ingress<'a>>,
        ) {
            fbb.finish(root, None);
        }

        #[inline]
        pub fn finish_size_prefixed_ingress_buffer<'a, 'b>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            root: flatbuffers::WIPOffset<Ingress<'a>>,
        ) {
            fbb.finish_size_prefixed(root, None);
        }
    } // pub mod Ingress
} // pub mod EncodingBench
